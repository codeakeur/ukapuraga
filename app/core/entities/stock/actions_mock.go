// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package stock

import (
	"context"
	"gomies/app/sdk/listing"
	"gomies/app/sdk/types"
	"sync"
)

// Ensure, that ActionsMock does implement Actions.
// If this is not the case, regenerate this file with moq.
var _ Actions = &ActionsMock{}

// ActionsMock is a mock implementation of Actions.
//
// 	func TestSomethingThatUsesActions(t *testing.T) {
//
// 		// make and configure a mocked Actions
// 		mockedActions := &ActionsMock{
// 			ArchiveMovementsFunc: func(ctx context.Context, filter Filter) error {
// 				panic("mock out the ArchiveMovements method")
// 			},
// 			ComputeStockFunc: func(ctx context.Context, filter Filter) (types.Quantity, error) {
// 				panic("mock out the ComputeStock method")
// 			},
// 			CreateStockFunc: func(ctx context.Context, st Stock) (Stock, error) {
// 				panic("mock out the CreateStock method")
// 			},
// 			GetStockByIDFunc: func(ctx context.Context, resourceID types.ID) (Stock, error) {
// 				panic("mock out the GetStockByID method")
// 			},
// 			ListMovementsFunc: func(ctx context.Context, filter Filter) ([]Movement, int, error) {
// 				panic("mock out the ListMovements method")
// 			},
// 			ListStocksFunc: func(ctx context.Context, filter listing.Filter) ([]Stock, int, error) {
// 				panic("mock out the ListStocks method")
// 			},
// 			RemoveMovementFunc: func(ctx context.Context, resourceID types.ID, movementID types.ID) error {
// 				panic("mock out the RemoveMovement method")
// 			},
// 			RemoveReservedFunc: func(ctx context.Context, agentID types.ID) error {
// 				panic("mock out the RemoveReserved method")
// 			},
// 			RemoveStockFunc: func(ctx context.Context, resourceID types.ID) error {
// 				panic("mock out the RemoveStock method")
// 			},
// 			SaveMovementsFunc: func(ctx context.Context, movement Movement) (Movement, error) {
// 				panic("mock out the SaveMovements method")
// 			},
// 			UpdateReservedFunc: func(ctx context.Context, agentID types.ID) error {
// 				panic("mock out the UpdateReserved method")
// 			},
// 			UpdateStockFunc: func(ctx context.Context, st Stock) error {
// 				panic("mock out the UpdateStock method")
// 			},
// 		}
//
// 		// use mockedActions in code that requires Actions
// 		// and then make assertions.
//
// 	}
type ActionsMock struct {
	// ArchiveMovementsFunc mocks the ArchiveMovements method.
	ArchiveMovementsFunc func(ctx context.Context, filter Filter) error

	// ComputeStockFunc mocks the ComputeStock method.
	ComputeStockFunc func(ctx context.Context, filter Filter) (types.Quantity, error)

	// CreateStockFunc mocks the CreateStock method.
	CreateStockFunc func(ctx context.Context, st Stock) (Stock, error)

	// GetStockByIDFunc mocks the GetStockByID method.
	GetStockByIDFunc func(ctx context.Context, resourceID types.ID) (Stock, error)

	// ListMovementsFunc mocks the ListMovements method.
	ListMovementsFunc func(ctx context.Context, filter Filter) ([]Movement, int, error)

	// ListStocksFunc mocks the ListStocks method.
	ListStocksFunc func(ctx context.Context, filter listing.Filter) ([]Stock, int, error)

	// RemoveMovementFunc mocks the RemoveMovement method.
	RemoveMovementFunc func(ctx context.Context, resourceID types.ID, movementID types.ID) error

	// RemoveReservedFunc mocks the RemoveReserved method.
	RemoveReservedFunc func(ctx context.Context, agentID types.ID) error

	// RemoveStockFunc mocks the RemoveStock method.
	RemoveStockFunc func(ctx context.Context, resourceID types.ID) error

	// SaveMovementsFunc mocks the SaveMovements method.
	SaveMovementsFunc func(ctx context.Context, movement Movement) (Movement, error)

	// UpdateReservedFunc mocks the UpdateReserved method.
	UpdateReservedFunc func(ctx context.Context, agentID types.ID) error

	// UpdateStockFunc mocks the UpdateStock method.
	UpdateStockFunc func(ctx context.Context, st Stock) error

	// calls tracks calls to the methods.
	calls struct {
		// ArchiveMovements holds details about calls to the ArchiveMovements method.
		ArchiveMovements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter Filter
		}
		// ComputeStock holds details about calls to the ComputeStock method.
		ComputeStock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter Filter
		}
		// CreateStock holds details about calls to the CreateStock method.
		CreateStock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// St is the st argument value.
			St Stock
		}
		// GetStockByID holds details about calls to the GetStockByID method.
		GetStockByID []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ResourceID is the resourceID argument value.
			ResourceID types.ID
		}
		// ListMovements holds details about calls to the ListMovements method.
		ListMovements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter Filter
		}
		// ListStocks holds details about calls to the ListStocks method.
		ListStocks []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Filter is the filter argument value.
			Filter listing.Filter
		}
		// RemoveMovement holds details about calls to the RemoveMovement method.
		RemoveMovement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ResourceID is the resourceID argument value.
			ResourceID types.ID
			// MovementID is the movementID argument value.
			MovementID types.ID
		}
		// RemoveReserved holds details about calls to the RemoveReserved method.
		RemoveReserved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID types.ID
		}
		// RemoveStock holds details about calls to the RemoveStock method.
		RemoveStock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ResourceID is the resourceID argument value.
			ResourceID types.ID
		}
		// SaveMovements holds details about calls to the SaveMovements method.
		SaveMovements []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Movement is the movement argument value.
			Movement Movement
		}
		// UpdateReserved holds details about calls to the UpdateReserved method.
		UpdateReserved []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// AgentID is the agentID argument value.
			AgentID types.ID
		}
		// UpdateStock holds details about calls to the UpdateStock method.
		UpdateStock []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// St is the st argument value.
			St Stock
		}
	}
	lockArchiveMovements sync.RWMutex
	lockComputeStock     sync.RWMutex
	lockCreateStock      sync.RWMutex
	lockGetStockByID     sync.RWMutex
	lockListMovements    sync.RWMutex
	lockListStocks       sync.RWMutex
	lockRemoveMovement   sync.RWMutex
	lockRemoveReserved   sync.RWMutex
	lockRemoveStock      sync.RWMutex
	lockSaveMovements    sync.RWMutex
	lockUpdateReserved   sync.RWMutex
	lockUpdateStock      sync.RWMutex
}

// ArchiveMovements calls ArchiveMovementsFunc.
func (mock *ActionsMock) ArchiveMovements(ctx context.Context, filter Filter) error {
	if mock.ArchiveMovementsFunc == nil {
		panic("ActionsMock.ArchiveMovementsFunc: method is nil but Actions.ArchiveMovements was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter Filter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockArchiveMovements.Lock()
	mock.calls.ArchiveMovements = append(mock.calls.ArchiveMovements, callInfo)
	mock.lockArchiveMovements.Unlock()
	return mock.ArchiveMovementsFunc(ctx, filter)
}

// ArchiveMovementsCalls gets all the calls that were made to ArchiveMovements.
// Check the length with:
//     len(mockedActions.ArchiveMovementsCalls())
func (mock *ActionsMock) ArchiveMovementsCalls() []struct {
	Ctx    context.Context
	Filter Filter
} {
	var calls []struct {
		Ctx    context.Context
		Filter Filter
	}
	mock.lockArchiveMovements.RLock()
	calls = mock.calls.ArchiveMovements
	mock.lockArchiveMovements.RUnlock()
	return calls
}

// ComputeStock calls ComputeStockFunc.
func (mock *ActionsMock) ComputeStock(ctx context.Context, filter Filter) (types.Quantity, error) {
	if mock.ComputeStockFunc == nil {
		panic("ActionsMock.ComputeStockFunc: method is nil but Actions.ComputeStock was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter Filter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockComputeStock.Lock()
	mock.calls.ComputeStock = append(mock.calls.ComputeStock, callInfo)
	mock.lockComputeStock.Unlock()
	return mock.ComputeStockFunc(ctx, filter)
}

// ComputeStockCalls gets all the calls that were made to ComputeStock.
// Check the length with:
//     len(mockedActions.ComputeStockCalls())
func (mock *ActionsMock) ComputeStockCalls() []struct {
	Ctx    context.Context
	Filter Filter
} {
	var calls []struct {
		Ctx    context.Context
		Filter Filter
	}
	mock.lockComputeStock.RLock()
	calls = mock.calls.ComputeStock
	mock.lockComputeStock.RUnlock()
	return calls
}

// CreateStock calls CreateStockFunc.
func (mock *ActionsMock) CreateStock(ctx context.Context, st Stock) (Stock, error) {
	if mock.CreateStockFunc == nil {
		panic("ActionsMock.CreateStockFunc: method is nil but Actions.CreateStock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		St  Stock
	}{
		Ctx: ctx,
		St:  st,
	}
	mock.lockCreateStock.Lock()
	mock.calls.CreateStock = append(mock.calls.CreateStock, callInfo)
	mock.lockCreateStock.Unlock()
	return mock.CreateStockFunc(ctx, st)
}

// CreateStockCalls gets all the calls that were made to CreateStock.
// Check the length with:
//     len(mockedActions.CreateStockCalls())
func (mock *ActionsMock) CreateStockCalls() []struct {
	Ctx context.Context
	St  Stock
} {
	var calls []struct {
		Ctx context.Context
		St  Stock
	}
	mock.lockCreateStock.RLock()
	calls = mock.calls.CreateStock
	mock.lockCreateStock.RUnlock()
	return calls
}

// GetStockByID calls GetStockByIDFunc.
func (mock *ActionsMock) GetStockByID(ctx context.Context, resourceID types.ID) (Stock, error) {
	if mock.GetStockByIDFunc == nil {
		panic("ActionsMock.GetStockByIDFunc: method is nil but Actions.GetStockByID was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ResourceID types.ID
	}{
		Ctx:        ctx,
		ResourceID: resourceID,
	}
	mock.lockGetStockByID.Lock()
	mock.calls.GetStockByID = append(mock.calls.GetStockByID, callInfo)
	mock.lockGetStockByID.Unlock()
	return mock.GetStockByIDFunc(ctx, resourceID)
}

// GetStockByIDCalls gets all the calls that were made to GetStockByID.
// Check the length with:
//     len(mockedActions.GetStockByIDCalls())
func (mock *ActionsMock) GetStockByIDCalls() []struct {
	Ctx        context.Context
	ResourceID types.ID
} {
	var calls []struct {
		Ctx        context.Context
		ResourceID types.ID
	}
	mock.lockGetStockByID.RLock()
	calls = mock.calls.GetStockByID
	mock.lockGetStockByID.RUnlock()
	return calls
}

// ListMovements calls ListMovementsFunc.
func (mock *ActionsMock) ListMovements(ctx context.Context, filter Filter) ([]Movement, int, error) {
	if mock.ListMovementsFunc == nil {
		panic("ActionsMock.ListMovementsFunc: method is nil but Actions.ListMovements was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter Filter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockListMovements.Lock()
	mock.calls.ListMovements = append(mock.calls.ListMovements, callInfo)
	mock.lockListMovements.Unlock()
	return mock.ListMovementsFunc(ctx, filter)
}

// ListMovementsCalls gets all the calls that were made to ListMovements.
// Check the length with:
//     len(mockedActions.ListMovementsCalls())
func (mock *ActionsMock) ListMovementsCalls() []struct {
	Ctx    context.Context
	Filter Filter
} {
	var calls []struct {
		Ctx    context.Context
		Filter Filter
	}
	mock.lockListMovements.RLock()
	calls = mock.calls.ListMovements
	mock.lockListMovements.RUnlock()
	return calls
}

// ListStocks calls ListStocksFunc.
func (mock *ActionsMock) ListStocks(ctx context.Context, filter listing.Filter) ([]Stock, int, error) {
	if mock.ListStocksFunc == nil {
		panic("ActionsMock.ListStocksFunc: method is nil but Actions.ListStocks was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Filter listing.Filter
	}{
		Ctx:    ctx,
		Filter: filter,
	}
	mock.lockListStocks.Lock()
	mock.calls.ListStocks = append(mock.calls.ListStocks, callInfo)
	mock.lockListStocks.Unlock()
	return mock.ListStocksFunc(ctx, filter)
}

// ListStocksCalls gets all the calls that were made to ListStocks.
// Check the length with:
//     len(mockedActions.ListStocksCalls())
func (mock *ActionsMock) ListStocksCalls() []struct {
	Ctx    context.Context
	Filter listing.Filter
} {
	var calls []struct {
		Ctx    context.Context
		Filter listing.Filter
	}
	mock.lockListStocks.RLock()
	calls = mock.calls.ListStocks
	mock.lockListStocks.RUnlock()
	return calls
}

// RemoveMovement calls RemoveMovementFunc.
func (mock *ActionsMock) RemoveMovement(ctx context.Context, resourceID types.ID, movementID types.ID) error {
	if mock.RemoveMovementFunc == nil {
		panic("ActionsMock.RemoveMovementFunc: method is nil but Actions.RemoveMovement was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ResourceID types.ID
		MovementID types.ID
	}{
		Ctx:        ctx,
		ResourceID: resourceID,
		MovementID: movementID,
	}
	mock.lockRemoveMovement.Lock()
	mock.calls.RemoveMovement = append(mock.calls.RemoveMovement, callInfo)
	mock.lockRemoveMovement.Unlock()
	return mock.RemoveMovementFunc(ctx, resourceID, movementID)
}

// RemoveMovementCalls gets all the calls that were made to RemoveMovement.
// Check the length with:
//     len(mockedActions.RemoveMovementCalls())
func (mock *ActionsMock) RemoveMovementCalls() []struct {
	Ctx        context.Context
	ResourceID types.ID
	MovementID types.ID
} {
	var calls []struct {
		Ctx        context.Context
		ResourceID types.ID
		MovementID types.ID
	}
	mock.lockRemoveMovement.RLock()
	calls = mock.calls.RemoveMovement
	mock.lockRemoveMovement.RUnlock()
	return calls
}

// RemoveReserved calls RemoveReservedFunc.
func (mock *ActionsMock) RemoveReserved(ctx context.Context, agentID types.ID) error {
	if mock.RemoveReservedFunc == nil {
		panic("ActionsMock.RemoveReservedFunc: method is nil but Actions.RemoveReserved was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AgentID types.ID
	}{
		Ctx:     ctx,
		AgentID: agentID,
	}
	mock.lockRemoveReserved.Lock()
	mock.calls.RemoveReserved = append(mock.calls.RemoveReserved, callInfo)
	mock.lockRemoveReserved.Unlock()
	return mock.RemoveReservedFunc(ctx, agentID)
}

// RemoveReservedCalls gets all the calls that were made to RemoveReserved.
// Check the length with:
//     len(mockedActions.RemoveReservedCalls())
func (mock *ActionsMock) RemoveReservedCalls() []struct {
	Ctx     context.Context
	AgentID types.ID
} {
	var calls []struct {
		Ctx     context.Context
		AgentID types.ID
	}
	mock.lockRemoveReserved.RLock()
	calls = mock.calls.RemoveReserved
	mock.lockRemoveReserved.RUnlock()
	return calls
}

// RemoveStock calls RemoveStockFunc.
func (mock *ActionsMock) RemoveStock(ctx context.Context, resourceID types.ID) error {
	if mock.RemoveStockFunc == nil {
		panic("ActionsMock.RemoveStockFunc: method is nil but Actions.RemoveStock was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		ResourceID types.ID
	}{
		Ctx:        ctx,
		ResourceID: resourceID,
	}
	mock.lockRemoveStock.Lock()
	mock.calls.RemoveStock = append(mock.calls.RemoveStock, callInfo)
	mock.lockRemoveStock.Unlock()
	return mock.RemoveStockFunc(ctx, resourceID)
}

// RemoveStockCalls gets all the calls that were made to RemoveStock.
// Check the length with:
//     len(mockedActions.RemoveStockCalls())
func (mock *ActionsMock) RemoveStockCalls() []struct {
	Ctx        context.Context
	ResourceID types.ID
} {
	var calls []struct {
		Ctx        context.Context
		ResourceID types.ID
	}
	mock.lockRemoveStock.RLock()
	calls = mock.calls.RemoveStock
	mock.lockRemoveStock.RUnlock()
	return calls
}

// SaveMovements calls SaveMovementsFunc.
func (mock *ActionsMock) SaveMovements(ctx context.Context, movement Movement) (Movement, error) {
	if mock.SaveMovementsFunc == nil {
		panic("ActionsMock.SaveMovementsFunc: method is nil but Actions.SaveMovements was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Movement Movement
	}{
		Ctx:      ctx,
		Movement: movement,
	}
	mock.lockSaveMovements.Lock()
	mock.calls.SaveMovements = append(mock.calls.SaveMovements, callInfo)
	mock.lockSaveMovements.Unlock()
	return mock.SaveMovementsFunc(ctx, movement)
}

// SaveMovementsCalls gets all the calls that were made to SaveMovements.
// Check the length with:
//     len(mockedActions.SaveMovementsCalls())
func (mock *ActionsMock) SaveMovementsCalls() []struct {
	Ctx      context.Context
	Movement Movement
} {
	var calls []struct {
		Ctx      context.Context
		Movement Movement
	}
	mock.lockSaveMovements.RLock()
	calls = mock.calls.SaveMovements
	mock.lockSaveMovements.RUnlock()
	return calls
}

// UpdateReserved calls UpdateReservedFunc.
func (mock *ActionsMock) UpdateReserved(ctx context.Context, agentID types.ID) error {
	if mock.UpdateReservedFunc == nil {
		panic("ActionsMock.UpdateReservedFunc: method is nil but Actions.UpdateReserved was just called")
	}
	callInfo := struct {
		Ctx     context.Context
		AgentID types.ID
	}{
		Ctx:     ctx,
		AgentID: agentID,
	}
	mock.lockUpdateReserved.Lock()
	mock.calls.UpdateReserved = append(mock.calls.UpdateReserved, callInfo)
	mock.lockUpdateReserved.Unlock()
	return mock.UpdateReservedFunc(ctx, agentID)
}

// UpdateReservedCalls gets all the calls that were made to UpdateReserved.
// Check the length with:
//     len(mockedActions.UpdateReservedCalls())
func (mock *ActionsMock) UpdateReservedCalls() []struct {
	Ctx     context.Context
	AgentID types.ID
} {
	var calls []struct {
		Ctx     context.Context
		AgentID types.ID
	}
	mock.lockUpdateReserved.RLock()
	calls = mock.calls.UpdateReserved
	mock.lockUpdateReserved.RUnlock()
	return calls
}

// UpdateStock calls UpdateStockFunc.
func (mock *ActionsMock) UpdateStock(ctx context.Context, st Stock) error {
	if mock.UpdateStockFunc == nil {
		panic("ActionsMock.UpdateStockFunc: method is nil but Actions.UpdateStock was just called")
	}
	callInfo := struct {
		Ctx context.Context
		St  Stock
	}{
		Ctx: ctx,
		St:  st,
	}
	mock.lockUpdateStock.Lock()
	mock.calls.UpdateStock = append(mock.calls.UpdateStock, callInfo)
	mock.lockUpdateStock.Unlock()
	return mock.UpdateStockFunc(ctx, st)
}

// UpdateStockCalls gets all the calls that were made to UpdateStock.
// Check the length with:
//     len(mockedActions.UpdateStockCalls())
func (mock *ActionsMock) UpdateStockCalls() []struct {
	Ctx context.Context
	St  Stock
} {
	var calls []struct {
		Ctx context.Context
		St  Stock
	}
	mock.lockUpdateStock.RLock()
	calls = mock.calls.UpdateStock
	mock.lockUpdateStock.RUnlock()
	return calls
}
