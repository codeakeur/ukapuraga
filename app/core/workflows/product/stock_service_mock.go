// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package product

import (
	"context"
	"gomies/app/sdk/types"
	"sync"
)

// Ensure, that StockServiceMock does implement StockService.
// If this is not the case, regenerate this file with moq.
var _ StockService = &StockServiceMock{}

// StockServiceMock is a mock implementation of StockService.
//
// 	func TestSomethingThatUsesStockService(t *testing.T) {
//
// 		// make and configure a mocked StockService
// 		mockedStockService := &StockServiceMock{
// 			ComputeFunc: func(ctx context.Context, productID types.ID) (types.Quantity, error) {
// 				panic("mock out the Compute method")
// 			},
// 			ComputeSomeFunc: func(ctx context.Context, productID ...types.ID) ([]types.Quantity, error) {
// 				panic("mock out the ComputeSome method")
// 			},
// 		}
//
// 		// use mockedStockService in code that requires StockService
// 		// and then make assertions.
//
// 	}
type StockServiceMock struct {
	// ComputeFunc mocks the Compute method.
	ComputeFunc func(ctx context.Context, productID types.ID) (types.Quantity, error)

	// ComputeSomeFunc mocks the ComputeSome method.
	ComputeSomeFunc func(ctx context.Context, productID ...types.ID) ([]types.Quantity, error)

	// calls tracks calls to the methods.
	calls struct {
		// Compute holds details about calls to the Compute method.
		Compute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID types.ID
		}
		// ComputeSome holds details about calls to the ComputeSome method.
		ComputeSome []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID []types.ID
		}
	}
	lockCompute     sync.RWMutex
	lockComputeSome sync.RWMutex
}

// Compute calls ComputeFunc.
func (mock *StockServiceMock) Compute(ctx context.Context, productID types.ID) (types.Quantity, error) {
	if mock.ComputeFunc == nil {
		panic("StockServiceMock.ComputeFunc: method is nil but StockService.Compute was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID types.ID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockCompute.Lock()
	mock.calls.Compute = append(mock.calls.Compute, callInfo)
	mock.lockCompute.Unlock()
	return mock.ComputeFunc(ctx, productID)
}

// ComputeCalls gets all the calls that were made to Compute.
// Check the length with:
//     len(mockedStockService.ComputeCalls())
func (mock *StockServiceMock) ComputeCalls() []struct {
	Ctx       context.Context
	ProductID types.ID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID types.ID
	}
	mock.lockCompute.RLock()
	calls = mock.calls.Compute
	mock.lockCompute.RUnlock()
	return calls
}

// ComputeSome calls ComputeSomeFunc.
func (mock *StockServiceMock) ComputeSome(ctx context.Context, productID ...types.ID) ([]types.Quantity, error) {
	if mock.ComputeSomeFunc == nil {
		panic("StockServiceMock.ComputeSomeFunc: method is nil but StockService.ComputeSome was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID []types.ID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockComputeSome.Lock()
	mock.calls.ComputeSome = append(mock.calls.ComputeSome, callInfo)
	mock.lockComputeSome.Unlock()
	return mock.ComputeSomeFunc(ctx, productID...)
}

// ComputeSomeCalls gets all the calls that were made to ComputeSome.
// Check the length with:
//     len(mockedStockService.ComputeSomeCalls())
func (mock *StockServiceMock) ComputeSomeCalls() []struct {
	Ctx       context.Context
	ProductID []types.ID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID []types.ID
	}
	mock.lockComputeSome.RLock()
	calls = mock.calls.ComputeSome
	mock.lockComputeSome.RUnlock()
	return calls
}
