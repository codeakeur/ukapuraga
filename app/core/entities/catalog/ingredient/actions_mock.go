// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ingredient

import (
	"context"
	"gomies/app/sdk/types"
	"sync"
)

// Ensure, that ActionsMock does implement Actions.
// If this is not the case, regenerate this file with moq.
var _ Actions = &ActionsMock{}

// ActionsMock is a mock implementation of Actions.
//
// 	func TestSomethingThatUsesActions(t *testing.T) {
//
// 		// make and configure a mocked Actions
// 		mockedActions := &ActionsMock{
// 			ListIngredientsFunc: func(ctx context.Context, productID types.ID) ([]Ingredient, error) {
// 				panic("mock out the ListIngredients method")
// 			},
// 			RemoveAllIngredientsFunc: func(ctx context.Context, productID types.ID) error {
// 				panic("mock out the RemoveAllIngredients method")
// 			},
// 			RemoveIngredientFunc: func(ctx context.Context, ingredientID types.ID) error {
// 				panic("mock out the RemoveIngredient method")
// 			},
// 			SaveIngredientFunc: func(ctx context.Context, ingredient Ingredient) (Ingredient, error) {
// 				panic("mock out the SaveIngredient method")
// 			},
// 		}
//
// 		// use mockedActions in code that requires Actions
// 		// and then make assertions.
//
// 	}
type ActionsMock struct {
	// ListIngredientsFunc mocks the ListIngredients method.
	ListIngredientsFunc func(ctx context.Context, productID types.ID) ([]Ingredient, error)

	// RemoveAllIngredientsFunc mocks the RemoveAllIngredients method.
	RemoveAllIngredientsFunc func(ctx context.Context, productID types.ID) error

	// RemoveIngredientFunc mocks the RemoveIngredient method.
	RemoveIngredientFunc func(ctx context.Context, ingredientID types.ID) error

	// SaveIngredientFunc mocks the SaveIngredient method.
	SaveIngredientFunc func(ctx context.Context, ingredient Ingredient) (Ingredient, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListIngredients holds details about calls to the ListIngredients method.
		ListIngredients []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID types.ID
		}
		// RemoveAllIngredients holds details about calls to the RemoveAllIngredients method.
		RemoveAllIngredients []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID types.ID
		}
		// RemoveIngredient holds details about calls to the RemoveIngredient method.
		RemoveIngredient []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// IngredientID is the ingredientID argument value.
			IngredientID types.ID
		}
		// SaveIngredient holds details about calls to the SaveIngredient method.
		SaveIngredient []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Ingredient is the ingredient argument value.
			Ingredient Ingredient
		}
	}
	lockListIngredients      sync.RWMutex
	lockRemoveAllIngredients sync.RWMutex
	lockRemoveIngredient     sync.RWMutex
	lockSaveIngredient       sync.RWMutex
}

// ListIngredients calls ListIngredientsFunc.
func (mock *ActionsMock) ListIngredients(ctx context.Context, productID types.ID) ([]Ingredient, error) {
	if mock.ListIngredientsFunc == nil {
		panic("ActionsMock.ListIngredientsFunc: method is nil but Actions.ListIngredients was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID types.ID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockListIngredients.Lock()
	mock.calls.ListIngredients = append(mock.calls.ListIngredients, callInfo)
	mock.lockListIngredients.Unlock()
	return mock.ListIngredientsFunc(ctx, productID)
}

// ListIngredientsCalls gets all the calls that were made to ListIngredients.
// Check the length with:
//     len(mockedActions.ListIngredientsCalls())
func (mock *ActionsMock) ListIngredientsCalls() []struct {
	Ctx       context.Context
	ProductID types.ID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID types.ID
	}
	mock.lockListIngredients.RLock()
	calls = mock.calls.ListIngredients
	mock.lockListIngredients.RUnlock()
	return calls
}

// RemoveAllIngredients calls RemoveAllIngredientsFunc.
func (mock *ActionsMock) RemoveAllIngredients(ctx context.Context, productID types.ID) error {
	if mock.RemoveAllIngredientsFunc == nil {
		panic("ActionsMock.RemoveAllIngredientsFunc: method is nil but Actions.RemoveAllIngredients was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID types.ID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockRemoveAllIngredients.Lock()
	mock.calls.RemoveAllIngredients = append(mock.calls.RemoveAllIngredients, callInfo)
	mock.lockRemoveAllIngredients.Unlock()
	return mock.RemoveAllIngredientsFunc(ctx, productID)
}

// RemoveAllIngredientsCalls gets all the calls that were made to RemoveAllIngredients.
// Check the length with:
//     len(mockedActions.RemoveAllIngredientsCalls())
func (mock *ActionsMock) RemoveAllIngredientsCalls() []struct {
	Ctx       context.Context
	ProductID types.ID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID types.ID
	}
	mock.lockRemoveAllIngredients.RLock()
	calls = mock.calls.RemoveAllIngredients
	mock.lockRemoveAllIngredients.RUnlock()
	return calls
}

// RemoveIngredient calls RemoveIngredientFunc.
func (mock *ActionsMock) RemoveIngredient(ctx context.Context, ingredientID types.ID) error {
	if mock.RemoveIngredientFunc == nil {
		panic("ActionsMock.RemoveIngredientFunc: method is nil but Actions.RemoveIngredient was just called")
	}
	callInfo := struct {
		Ctx          context.Context
		IngredientID types.ID
	}{
		Ctx:          ctx,
		IngredientID: ingredientID,
	}
	mock.lockRemoveIngredient.Lock()
	mock.calls.RemoveIngredient = append(mock.calls.RemoveIngredient, callInfo)
	mock.lockRemoveIngredient.Unlock()
	return mock.RemoveIngredientFunc(ctx, ingredientID)
}

// RemoveIngredientCalls gets all the calls that were made to RemoveIngredient.
// Check the length with:
//     len(mockedActions.RemoveIngredientCalls())
func (mock *ActionsMock) RemoveIngredientCalls() []struct {
	Ctx          context.Context
	IngredientID types.ID
} {
	var calls []struct {
		Ctx          context.Context
		IngredientID types.ID
	}
	mock.lockRemoveIngredient.RLock()
	calls = mock.calls.RemoveIngredient
	mock.lockRemoveIngredient.RUnlock()
	return calls
}

// SaveIngredient calls SaveIngredientFunc.
func (mock *ActionsMock) SaveIngredient(ctx context.Context, ingredient Ingredient) (Ingredient, error) {
	if mock.SaveIngredientFunc == nil {
		panic("ActionsMock.SaveIngredientFunc: method is nil but Actions.SaveIngredient was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Ingredient Ingredient
	}{
		Ctx:        ctx,
		Ingredient: ingredient,
	}
	mock.lockSaveIngredient.Lock()
	mock.calls.SaveIngredient = append(mock.calls.SaveIngredient, callInfo)
	mock.lockSaveIngredient.Unlock()
	return mock.SaveIngredientFunc(ctx, ingredient)
}

// SaveIngredientCalls gets all the calls that were made to SaveIngredient.
// Check the length with:
//     len(mockedActions.SaveIngredientCalls())
func (mock *ActionsMock) SaveIngredientCalls() []struct {
	Ctx        context.Context
	Ingredient Ingredient
} {
	var calls []struct {
		Ctx        context.Context
		Ingredient Ingredient
	}
	mock.lockSaveIngredient.RLock()
	calls = mock.calls.SaveIngredient
	mock.lockSaveIngredient.RUnlock()
	return calls
}
