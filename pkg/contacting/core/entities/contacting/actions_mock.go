// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package contacting

import (
	"context"
	"gomies/pkg/sdk/types"
	"sync"
)

// Ensure, that ActionsMock does implement Actions.
// If this is not the case, regenerate this file with moq.
var _ Actions = &ActionsMock{}

// ActionsMock is a mock implementation of Actions.
//
// 	func TestSomethingThatUsesActions(t *testing.T) {
//
// 		// make and configure a mocked Actions
// 		mockedActions := &ActionsMock{
// 			GetAddressFunc: func(ctx context.Context, target types.UID, addressID types.UID) (Address, error) {
// 				panic("mock out the GetAddress method")
// 			},
// 			GetPhoneFunc: func(ctx context.Context, target types.UID, id types.UID) (Phone, error) {
// 				panic("mock out the GetPhone method")
// 			},
// 			ListAddressesFunc: func(ctx context.Context, target types.UID) ([]Address, error) {
// 				panic("mock out the ListAddresses method")
// 			},
// 			ListPhonesFunc: func(ctx context.Context, target types.UID) ([]Phone, error) {
// 				panic("mock out the ListPhones method")
// 			},
// 			RemoveAddressesFunc: func(ctx context.Context, target types.UID, ids ...types.UID) error {
// 				panic("mock out the RemoveAddresses method")
// 			},
// 			RemovePhonesFunc: func(ctx context.Context, target types.UID, ids ...types.UID) error {
// 				panic("mock out the RemovePhones method")
// 			},
// 			SaveAddressesFunc: func(ctx context.Context, target types.UID, addresses ...Address) ([]Address, error) {
// 				panic("mock out the SaveAddresses method")
// 			},
// 			SavePhonesFunc: func(ctx context.Context, target types.UID, phones ...Phone) ([]Phone, error) {
// 				panic("mock out the SavePhones method")
// 			},
// 		}
//
// 		// use mockedActions in code that requires Actions
// 		// and then make assertions.
//
// 	}
type ActionsMock struct {
	// GetAddressFunc mocks the GetAddress method.
	GetAddressFunc func(ctx context.Context, target types.UID, addressID types.UID) (Address, error)

	// GetPhoneFunc mocks the GetPhone method.
	GetPhoneFunc func(ctx context.Context, target types.UID, id types.UID) (Phone, error)

	// ListAddressesFunc mocks the ListAddresses method.
	ListAddressesFunc func(ctx context.Context, target types.UID) ([]Address, error)

	// ListPhonesFunc mocks the ListPhones method.
	ListPhonesFunc func(ctx context.Context, target types.UID) ([]Phone, error)

	// RemoveAddressesFunc mocks the RemoveAddresses method.
	RemoveAddressesFunc func(ctx context.Context, target types.UID, ids ...types.UID) error

	// RemovePhonesFunc mocks the RemovePhones method.
	RemovePhonesFunc func(ctx context.Context, target types.UID, ids ...types.UID) error

	// SaveAddressesFunc mocks the SaveAddresses method.
	SaveAddressesFunc func(ctx context.Context, target types.UID, addresses ...Address) ([]Address, error)

	// SavePhonesFunc mocks the SavePhones method.
	SavePhonesFunc func(ctx context.Context, target types.UID, phones ...Phone) ([]Phone, error)

	// calls tracks calls to the methods.
	calls struct {
		// GetAddress holds details about calls to the GetAddress method.
		GetAddress []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// AddressID is the addressID argument value.
			AddressID types.UID
		}
		// GetPhone holds details about calls to the GetPhone method.
		GetPhone []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// ID is the id argument value.
			ID types.UID
		}
		// ListAddresses holds details about calls to the ListAddresses method.
		ListAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
		}
		// ListPhones holds details about calls to the ListPhones method.
		ListPhones []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
		}
		// RemoveAddresses holds details about calls to the RemoveAddresses method.
		RemoveAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// Ids is the ids argument value.
			Ids []types.UID
		}
		// RemovePhones holds details about calls to the RemovePhones method.
		RemovePhones []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// Ids is the ids argument value.
			Ids []types.UID
		}
		// SaveAddresses holds details about calls to the SaveAddresses method.
		SaveAddresses []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// Addresses is the addresses argument value.
			Addresses []Address
		}
		// SavePhones holds details about calls to the SavePhones method.
		SavePhones []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Target is the target argument value.
			Target types.UID
			// Phones is the phones argument value.
			Phones []Phone
		}
	}
	lockGetAddress      sync.RWMutex
	lockGetPhone        sync.RWMutex
	lockListAddresses   sync.RWMutex
	lockListPhones      sync.RWMutex
	lockRemoveAddresses sync.RWMutex
	lockRemovePhones    sync.RWMutex
	lockSaveAddresses   sync.RWMutex
	lockSavePhones      sync.RWMutex
}

// GetAddress calls GetAddressFunc.
func (mock *ActionsMock) GetAddress(ctx context.Context, target types.UID, addressID types.UID) (Address, error) {
	if mock.GetAddressFunc == nil {
		panic("ActionsMock.GetAddressFunc: method is nil but Actions.GetAddress was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Target    types.UID
		AddressID types.UID
	}{
		Ctx:       ctx,
		Target:    target,
		AddressID: addressID,
	}
	mock.lockGetAddress.Lock()
	mock.calls.GetAddress = append(mock.calls.GetAddress, callInfo)
	mock.lockGetAddress.Unlock()
	return mock.GetAddressFunc(ctx, target, addressID)
}

// GetAddressCalls gets all the calls that were made to GetAddress.
// Check the length with:
//     len(mockedActions.GetAddressCalls())
func (mock *ActionsMock) GetAddressCalls() []struct {
	Ctx       context.Context
	Target    types.UID
	AddressID types.UID
} {
	var calls []struct {
		Ctx       context.Context
		Target    types.UID
		AddressID types.UID
	}
	mock.lockGetAddress.RLock()
	calls = mock.calls.GetAddress
	mock.lockGetAddress.RUnlock()
	return calls
}

// GetPhone calls GetPhoneFunc.
func (mock *ActionsMock) GetPhone(ctx context.Context, target types.UID, id types.UID) (Phone, error) {
	if mock.GetPhoneFunc == nil {
		panic("ActionsMock.GetPhoneFunc: method is nil but Actions.GetPhone was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
		ID     types.UID
	}{
		Ctx:    ctx,
		Target: target,
		ID:     id,
	}
	mock.lockGetPhone.Lock()
	mock.calls.GetPhone = append(mock.calls.GetPhone, callInfo)
	mock.lockGetPhone.Unlock()
	return mock.GetPhoneFunc(ctx, target, id)
}

// GetPhoneCalls gets all the calls that were made to GetPhone.
// Check the length with:
//     len(mockedActions.GetPhoneCalls())
func (mock *ActionsMock) GetPhoneCalls() []struct {
	Ctx    context.Context
	Target types.UID
	ID     types.UID
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
		ID     types.UID
	}
	mock.lockGetPhone.RLock()
	calls = mock.calls.GetPhone
	mock.lockGetPhone.RUnlock()
	return calls
}

// ListAddresses calls ListAddressesFunc.
func (mock *ActionsMock) ListAddresses(ctx context.Context, target types.UID) ([]Address, error) {
	if mock.ListAddressesFunc == nil {
		panic("ActionsMock.ListAddressesFunc: method is nil but Actions.ListAddresses was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
	}{
		Ctx:    ctx,
		Target: target,
	}
	mock.lockListAddresses.Lock()
	mock.calls.ListAddresses = append(mock.calls.ListAddresses, callInfo)
	mock.lockListAddresses.Unlock()
	return mock.ListAddressesFunc(ctx, target)
}

// ListAddressesCalls gets all the calls that were made to ListAddresses.
// Check the length with:
//     len(mockedActions.ListAddressesCalls())
func (mock *ActionsMock) ListAddressesCalls() []struct {
	Ctx    context.Context
	Target types.UID
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
	}
	mock.lockListAddresses.RLock()
	calls = mock.calls.ListAddresses
	mock.lockListAddresses.RUnlock()
	return calls
}

// ListPhones calls ListPhonesFunc.
func (mock *ActionsMock) ListPhones(ctx context.Context, target types.UID) ([]Phone, error) {
	if mock.ListPhonesFunc == nil {
		panic("ActionsMock.ListPhonesFunc: method is nil but Actions.ListPhones was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
	}{
		Ctx:    ctx,
		Target: target,
	}
	mock.lockListPhones.Lock()
	mock.calls.ListPhones = append(mock.calls.ListPhones, callInfo)
	mock.lockListPhones.Unlock()
	return mock.ListPhonesFunc(ctx, target)
}

// ListPhonesCalls gets all the calls that were made to ListPhones.
// Check the length with:
//     len(mockedActions.ListPhonesCalls())
func (mock *ActionsMock) ListPhonesCalls() []struct {
	Ctx    context.Context
	Target types.UID
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
	}
	mock.lockListPhones.RLock()
	calls = mock.calls.ListPhones
	mock.lockListPhones.RUnlock()
	return calls
}

// RemoveAddresses calls RemoveAddressesFunc.
func (mock *ActionsMock) RemoveAddresses(ctx context.Context, target types.UID, ids ...types.UID) error {
	if mock.RemoveAddressesFunc == nil {
		panic("ActionsMock.RemoveAddressesFunc: method is nil but Actions.RemoveAddresses was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
		Ids    []types.UID
	}{
		Ctx:    ctx,
		Target: target,
		Ids:    ids,
	}
	mock.lockRemoveAddresses.Lock()
	mock.calls.RemoveAddresses = append(mock.calls.RemoveAddresses, callInfo)
	mock.lockRemoveAddresses.Unlock()
	return mock.RemoveAddressesFunc(ctx, target, ids...)
}

// RemoveAddressesCalls gets all the calls that were made to RemoveAddresses.
// Check the length with:
//     len(mockedActions.RemoveAddressesCalls())
func (mock *ActionsMock) RemoveAddressesCalls() []struct {
	Ctx    context.Context
	Target types.UID
	Ids    []types.UID
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
		Ids    []types.UID
	}
	mock.lockRemoveAddresses.RLock()
	calls = mock.calls.RemoveAddresses
	mock.lockRemoveAddresses.RUnlock()
	return calls
}

// RemovePhones calls RemovePhonesFunc.
func (mock *ActionsMock) RemovePhones(ctx context.Context, target types.UID, ids ...types.UID) error {
	if mock.RemovePhonesFunc == nil {
		panic("ActionsMock.RemovePhonesFunc: method is nil but Actions.RemovePhones was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
		Ids    []types.UID
	}{
		Ctx:    ctx,
		Target: target,
		Ids:    ids,
	}
	mock.lockRemovePhones.Lock()
	mock.calls.RemovePhones = append(mock.calls.RemovePhones, callInfo)
	mock.lockRemovePhones.Unlock()
	return mock.RemovePhonesFunc(ctx, target, ids...)
}

// RemovePhonesCalls gets all the calls that were made to RemovePhones.
// Check the length with:
//     len(mockedActions.RemovePhonesCalls())
func (mock *ActionsMock) RemovePhonesCalls() []struct {
	Ctx    context.Context
	Target types.UID
	Ids    []types.UID
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
		Ids    []types.UID
	}
	mock.lockRemovePhones.RLock()
	calls = mock.calls.RemovePhones
	mock.lockRemovePhones.RUnlock()
	return calls
}

// SaveAddresses calls SaveAddressesFunc.
func (mock *ActionsMock) SaveAddresses(ctx context.Context, target types.UID, addresses ...Address) ([]Address, error) {
	if mock.SaveAddressesFunc == nil {
		panic("ActionsMock.SaveAddressesFunc: method is nil but Actions.SaveAddresses was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		Target    types.UID
		Addresses []Address
	}{
		Ctx:       ctx,
		Target:    target,
		Addresses: addresses,
	}
	mock.lockSaveAddresses.Lock()
	mock.calls.SaveAddresses = append(mock.calls.SaveAddresses, callInfo)
	mock.lockSaveAddresses.Unlock()
	return mock.SaveAddressesFunc(ctx, target, addresses...)
}

// SaveAddressesCalls gets all the calls that were made to SaveAddresses.
// Check the length with:
//     len(mockedActions.SaveAddressesCalls())
func (mock *ActionsMock) SaveAddressesCalls() []struct {
	Ctx       context.Context
	Target    types.UID
	Addresses []Address
} {
	var calls []struct {
		Ctx       context.Context
		Target    types.UID
		Addresses []Address
	}
	mock.lockSaveAddresses.RLock()
	calls = mock.calls.SaveAddresses
	mock.lockSaveAddresses.RUnlock()
	return calls
}

// SavePhones calls SavePhonesFunc.
func (mock *ActionsMock) SavePhones(ctx context.Context, target types.UID, phones ...Phone) ([]Phone, error) {
	if mock.SavePhonesFunc == nil {
		panic("ActionsMock.SavePhonesFunc: method is nil but Actions.SavePhones was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Target types.UID
		Phones []Phone
	}{
		Ctx:    ctx,
		Target: target,
		Phones: phones,
	}
	mock.lockSavePhones.Lock()
	mock.calls.SavePhones = append(mock.calls.SavePhones, callInfo)
	mock.lockSavePhones.Unlock()
	return mock.SavePhonesFunc(ctx, target, phones...)
}

// SavePhonesCalls gets all the calls that were made to SavePhones.
// Check the length with:
//     len(mockedActions.SavePhonesCalls())
func (mock *ActionsMock) SavePhonesCalls() []struct {
	Ctx    context.Context
	Target types.UID
	Phones []Phone
} {
	var calls []struct {
		Ctx    context.Context
		Target types.UID
		Phones []Phone
	}
	mock.lockSavePhones.RLock()
	calls = mock.calls.SavePhones
	mock.lockSavePhones.RUnlock()
	return calls
}
