// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package session

import (
	"context"
	"sync"
)

// Ensure, that ManagerMock does implement Manager.
// If this is not the case, regenerate this file with moq.
var _ Manager = &ManagerMock{}

// ManagerMock is a mock implementation of Manager.
//
// 	func TestSomethingThatUsesManager(t *testing.T) {
//
// 		// make and configure a mocked Manager
// 		mockedManager := &ManagerMock{
// 			CreateFunc: func(ctx context.Context, op Session) (context.Context, Session, error) {
// 				panic("mock out the Create method")
// 			},
// 			RetrieveFunc: func(ctx context.Context, digest string, updateExpiration bool) (context.Context, Session, error) {
// 				panic("mock out the Retrieve method")
// 			},
// 		}
//
// 		// use mockedManager in code that requires Manager
// 		// and then make assertions.
//
// 	}
type ManagerMock struct {
	// CreateFunc mocks the Create method.
	CreateFunc func(ctx context.Context, op Session) (context.Context, Session, error)

	// RetrieveFunc mocks the Retrieve method.
	RetrieveFunc func(ctx context.Context, digest string, updateExpiration bool) (context.Context, Session, error)

	// calls tracks calls to the methods.
	calls struct {
		// Create holds details about calls to the Create method.
		Create []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Op is the op argument value.
			Op Session
		}
		// Retrieve holds details about calls to the Retrieve method.
		Retrieve []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Digest is the digest argument value.
			Digest string
			// UpdateExpiration is the updateExpiration argument value.
			UpdateExpiration bool
		}
	}
	lockCreate   sync.RWMutex
	lockRetrieve sync.RWMutex
}

// Create calls CreateFunc.
func (mock *ManagerMock) Create(ctx context.Context, op Session) (context.Context, Session, error) {
	if mock.CreateFunc == nil {
		panic("ManagerMock.CreateFunc: method is nil but Manager.Create was just called")
	}
	callInfo := struct {
		Ctx context.Context
		Op  Session
	}{
		Ctx: ctx,
		Op:  op,
	}
	mock.lockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	mock.lockCreate.Unlock()
	return mock.CreateFunc(ctx, op)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedManager.CreateCalls())
func (mock *ManagerMock) CreateCalls() []struct {
	Ctx context.Context
	Op  Session
} {
	var calls []struct {
		Ctx context.Context
		Op  Session
	}
	mock.lockCreate.RLock()
	calls = mock.calls.Create
	mock.lockCreate.RUnlock()
	return calls
}

// Retrieve calls RetrieveFunc.
func (mock *ManagerMock) Retrieve(ctx context.Context, digest string, updateExpiration bool) (context.Context, Session, error) {
	if mock.RetrieveFunc == nil {
		panic("ManagerMock.RetrieveFunc: method is nil but Manager.Retrieve was just called")
	}
	callInfo := struct {
		Ctx              context.Context
		Digest           string
		UpdateExpiration bool
	}{
		Ctx:              ctx,
		Digest:           digest,
		UpdateExpiration: updateExpiration,
	}
	mock.lockRetrieve.Lock()
	mock.calls.Retrieve = append(mock.calls.Retrieve, callInfo)
	mock.lockRetrieve.Unlock()
	return mock.RetrieveFunc(ctx, digest, updateExpiration)
}

// RetrieveCalls gets all the calls that were made to Retrieve.
// Check the length with:
//     len(mockedManager.RetrieveCalls())
func (mock *ManagerMock) RetrieveCalls() []struct {
	Ctx              context.Context
	Digest           string
	UpdateExpiration bool
} {
	var calls []struct {
		Ctx              context.Context
		Digest           string
		UpdateExpiration bool
	}
	mock.lockRetrieve.RLock()
	calls = mock.calls.Retrieve
	mock.lockRetrieve.RUnlock()
	return calls
}
