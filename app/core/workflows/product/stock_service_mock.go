// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package product

import (
	"context"
	"gomies/app/core/entities/catalog/product"
	"gomies/pkg/sdk/types"
	"sync"
)

// Ensure, that StockServiceMock does implement StockService.
// If this is not the case, regenerate this file with moq.
var _ StockService = &StockServiceMock{}

// StockServiceMock is a mock implementation of StockService.
//
// 	func TestSomethingThatUsesStockService(t *testing.T) {
//
// 		// make and configure a mocked StockService
// 		mockedStockService := &StockServiceMock{
// 			ComputeFunc: func(ctx context.Context, productID types.UID) (types.Quantity, error) {
// 				panic("mock out the Compute method")
// 			},
// 			ComputeSomeFunc: func(ctx context.Context, productID ...types.UID) ([]types.Quantity, error) {
// 				panic("mock out the ComputeSome method")
// 			},
// 			CreateMovementFunc: func(ctx context.Context, config product.Stock, resourceID types.UID, movement Movement) (types.Quantity, error) {
// 				panic("mock out the CreateMovement method")
// 			},
// 		}
//
// 		// use mockedStockService in code that requires StockService
// 		// and then make assertions.
//
// 	}
type StockServiceMock struct {
	// ComputeFunc mocks the Compute method.
	ComputeFunc func(ctx context.Context, productID types.UID) (types.Quantity, error)

	// ComputeSomeFunc mocks the ComputeSome method.
	ComputeSomeFunc func(ctx context.Context, productID ...types.UID) ([]types.Quantity, error)

	// CreateMovementFunc mocks the CreateMovement method.
	CreateMovementFunc func(ctx context.Context, config product.Stock, resourceID types.UID, movement Movement) (types.Quantity, error)

	// calls tracks calls to the methods.
	calls struct {
		// Compute holds details about calls to the Compute method.
		Compute []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID types.UID
		}
		// ComputeSome holds details about calls to the ComputeSome method.
		ComputeSome []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ProductID is the productID argument value.
			ProductID []types.UID
		}
		// CreateMovement holds details about calls to the CreateMovement method.
		CreateMovement []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Config is the config argument value.
			Config product.Stock
			// ResourceID is the resourceID argument value.
			ResourceID types.UID
			// Movement is the movement argument value.
			Movement Movement
		}
	}
	lockCompute        sync.RWMutex
	lockComputeSome    sync.RWMutex
	lockCreateMovement sync.RWMutex
}

// Compute calls ComputeFunc.
func (mock *StockServiceMock) Compute(ctx context.Context, productID types.UID) (types.Quantity, error) {
	if mock.ComputeFunc == nil {
		panic("StockServiceMock.ComputeFunc: method is nil but StockService.Compute was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID types.UID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockCompute.Lock()
	mock.calls.Compute = append(mock.calls.Compute, callInfo)
	mock.lockCompute.Unlock()
	return mock.ComputeFunc(ctx, productID)
}

// ComputeCalls gets all the calls that were made to Compute.
// Check the length with:
//     len(mockedStockService.ComputeCalls())
func (mock *StockServiceMock) ComputeCalls() []struct {
	Ctx       context.Context
	ProductID types.UID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID types.UID
	}
	mock.lockCompute.RLock()
	calls = mock.calls.Compute
	mock.lockCompute.RUnlock()
	return calls
}

// ComputeSome calls ComputeSomeFunc.
func (mock *StockServiceMock) ComputeSome(ctx context.Context, productID ...types.UID) ([]types.Quantity, error) {
	if mock.ComputeSomeFunc == nil {
		panic("StockServiceMock.ComputeSomeFunc: method is nil but StockService.ComputeSome was just called")
	}
	callInfo := struct {
		Ctx       context.Context
		ProductID []types.UID
	}{
		Ctx:       ctx,
		ProductID: productID,
	}
	mock.lockComputeSome.Lock()
	mock.calls.ComputeSome = append(mock.calls.ComputeSome, callInfo)
	mock.lockComputeSome.Unlock()
	return mock.ComputeSomeFunc(ctx, productID...)
}

// ComputeSomeCalls gets all the calls that were made to ComputeSome.
// Check the length with:
//     len(mockedStockService.ComputeSomeCalls())
func (mock *StockServiceMock) ComputeSomeCalls() []struct {
	Ctx       context.Context
	ProductID []types.UID
} {
	var calls []struct {
		Ctx       context.Context
		ProductID []types.UID
	}
	mock.lockComputeSome.RLock()
	calls = mock.calls.ComputeSome
	mock.lockComputeSome.RUnlock()
	return calls
}

// CreateMovement calls CreateMovementFunc.
func (mock *StockServiceMock) CreateMovement(ctx context.Context, config product.Stock, resourceID types.UID, movement Movement) (types.Quantity, error) {
	if mock.CreateMovementFunc == nil {
		panic("StockServiceMock.CreateMovementFunc: method is nil but StockService.CreateMovement was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Config     product.Stock
		ResourceID types.UID
		Movement   Movement
	}{
		Ctx:        ctx,
		Config:     config,
		ResourceID: resourceID,
		Movement:   movement,
	}
	mock.lockCreateMovement.Lock()
	mock.calls.CreateMovement = append(mock.calls.CreateMovement, callInfo)
	mock.lockCreateMovement.Unlock()
	return mock.CreateMovementFunc(ctx, config, resourceID, movement)
}

// CreateMovementCalls gets all the calls that were made to CreateMovement.
// Check the length with:
//     len(mockedStockService.CreateMovementCalls())
func (mock *StockServiceMock) CreateMovementCalls() []struct {
	Ctx        context.Context
	Config     product.Stock
	ResourceID types.UID
	Movement   Movement
} {
	var calls []struct {
		Ctx        context.Context
		Config     product.Stock
		ResourceID types.UID
		Movement   Movement
	}
	mock.lockCreateMovement.RLock()
	calls = mock.calls.CreateMovement
	mock.lockCreateMovement.RUnlock()
	return calls
}
