// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package product

import (
	"context"
	"gomies/app/core/entities/catalog/ingredient"
	"gomies/app/sdk/types"
	"sync"
)

// Ensure, that StockServiceMock does implement StockService.
// If this is not the case, regenerate this file with moq.
var _ StockService = &StockServiceMock{}

// StockServiceMock is a mock implementation of StockService.
//
// 	func TestSomethingThatUsesStockService(t *testing.T) {
//
// 		// make and configure a mocked StockService
// 		mockedStockService := &StockServiceMock{
// 			ConsumeResourcesFunc: func(ctx context.Context, reservationID types.ID) error {
// 				panic("mock out the ConsumeResources method")
// 			},
// 			FreeResourcesFunc: func(ctx context.Context, reservationID types.ID) error {
// 				panic("mock out the FreeResources method")
// 			},
// 			ReserveResourcesFunc: func(ctx context.Context, reservationID types.ID, resources ...ingredient.Ingredient) ([]ItemFailed, error) {
// 				panic("mock out the ReserveResources method")
// 			},
// 		}
//
// 		// use mockedStockService in code that requires StockService
// 		// and then make assertions.
//
// 	}
type StockServiceMock struct {
	// ConsumeResourcesFunc mocks the ConsumeResources method.
	ConsumeResourcesFunc func(ctx context.Context, reservationID types.ID) error

	// FreeResourcesFunc mocks the FreeResources method.
	FreeResourcesFunc func(ctx context.Context, reservationID types.ID) error

	// ReserveResourcesFunc mocks the ReserveResources method.
	ReserveResourcesFunc func(ctx context.Context, reservationID types.ID, resources ...ingredient.Ingredient) ([]ItemFailed, error)

	// calls tracks calls to the methods.
	calls struct {
		// ConsumeResources holds details about calls to the ConsumeResources method.
		ConsumeResources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID types.ID
		}
		// FreeResources holds details about calls to the FreeResources method.
		FreeResources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID types.ID
		}
		// ReserveResources holds details about calls to the ReserveResources method.
		ReserveResources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID types.ID
			// Resources is the resources argument value.
			Resources []ingredient.Ingredient
		}
	}
	lockConsumeResources sync.RWMutex
	lockFreeResources    sync.RWMutex
	lockReserveResources sync.RWMutex
}

// ConsumeResources calls ConsumeResourcesFunc.
func (mock *StockServiceMock) ConsumeResources(ctx context.Context, reservationID types.ID) error {
	if mock.ConsumeResourcesFunc == nil {
		panic("StockServiceMock.ConsumeResourcesFunc: method is nil but StockService.ConsumeResources was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID types.ID
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
	}
	mock.lockConsumeResources.Lock()
	mock.calls.ConsumeResources = append(mock.calls.ConsumeResources, callInfo)
	mock.lockConsumeResources.Unlock()
	return mock.ConsumeResourcesFunc(ctx, reservationID)
}

// ConsumeResourcesCalls gets all the calls that were made to ConsumeResources.
// Check the length with:
//     len(mockedStockService.ConsumeResourcesCalls())
func (mock *StockServiceMock) ConsumeResourcesCalls() []struct {
	Ctx           context.Context
	ReservationID types.ID
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID types.ID
	}
	mock.lockConsumeResources.RLock()
	calls = mock.calls.ConsumeResources
	mock.lockConsumeResources.RUnlock()
	return calls
}

// FreeResources calls FreeResourcesFunc.
func (mock *StockServiceMock) FreeResources(ctx context.Context, reservationID types.ID) error {
	if mock.FreeResourcesFunc == nil {
		panic("StockServiceMock.FreeResourcesFunc: method is nil but StockService.FreeResources was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID types.ID
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
	}
	mock.lockFreeResources.Lock()
	mock.calls.FreeResources = append(mock.calls.FreeResources, callInfo)
	mock.lockFreeResources.Unlock()
	return mock.FreeResourcesFunc(ctx, reservationID)
}

// FreeResourcesCalls gets all the calls that were made to FreeResources.
// Check the length with:
//     len(mockedStockService.FreeResourcesCalls())
func (mock *StockServiceMock) FreeResourcesCalls() []struct {
	Ctx           context.Context
	ReservationID types.ID
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID types.ID
	}
	mock.lockFreeResources.RLock()
	calls = mock.calls.FreeResources
	mock.lockFreeResources.RUnlock()
	return calls
}

// ReserveResources calls ReserveResourcesFunc.
func (mock *StockServiceMock) ReserveResources(ctx context.Context, reservationID types.ID, resources ...ingredient.Ingredient) ([]ItemFailed, error) {
	if mock.ReserveResourcesFunc == nil {
		panic("StockServiceMock.ReserveResourcesFunc: method is nil but StockService.ReserveResources was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID types.ID
		Resources     []ingredient.Ingredient
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
		Resources:     resources,
	}
	mock.lockReserveResources.Lock()
	mock.calls.ReserveResources = append(mock.calls.ReserveResources, callInfo)
	mock.lockReserveResources.Unlock()
	return mock.ReserveResourcesFunc(ctx, reservationID, resources...)
}

// ReserveResourcesCalls gets all the calls that were made to ReserveResources.
// Check the length with:
//     len(mockedStockService.ReserveResourcesCalls())
func (mock *StockServiceMock) ReserveResourcesCalls() []struct {
	Ctx           context.Context
	ReservationID types.ID
	Resources     []ingredient.Ingredient
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID types.ID
		Resources     []ingredient.Ingredient
	}
	mock.lockReserveResources.RLock()
	calls = mock.calls.ReserveResources
	mock.lockReserveResources.RUnlock()
	return calls
}
