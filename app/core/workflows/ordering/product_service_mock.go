// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package ordering

import (
	"context"
	"gomies/app/sdk/types"
	"sync"
)

// Ensure, that ProductServiceMock does implement ProductService.
// If this is not the case, regenerate this file with moq.
var _ ProductService = &ProductServiceMock{}

// ProductServiceMock is a mock implementation of ProductService.
//
// 	func TestSomethingThatUsesProductService(t *testing.T) {
//
// 		// make and configure a mocked ProductService
// 		mockedProductService := &ProductServiceMock{
// 			ReserveResourcesFunc: func(ctx context.Context, reservationID types.ID, reservation Reservation) (Reservation, error) {
// 				panic("mock out the ReserveResources method")
// 			},
// 			UpdateResourcesFunc: func(ctx context.Context, reservationID types.ID, consume bool) error {
// 				panic("mock out the UpdateResources method")
// 			},
// 		}
//
// 		// use mockedProductService in code that requires ProductService
// 		// and then make assertions.
//
// 	}
type ProductServiceMock struct {
	// ReserveResourcesFunc mocks the ReserveResources method.
	ReserveResourcesFunc func(ctx context.Context, reservationID types.ID, reservation Reservation) (Reservation, error)

	// UpdateResourcesFunc mocks the UpdateResources method.
	UpdateResourcesFunc func(ctx context.Context, reservationID types.ID, consume bool) error

	// calls tracks calls to the methods.
	calls struct {
		// ReserveResources holds details about calls to the ReserveResources method.
		ReserveResources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID types.ID
			// Reservation is the reservation argument value.
			Reservation Reservation
		}
		// UpdateResources holds details about calls to the UpdateResources method.
		UpdateResources []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ReservationID is the reservationID argument value.
			ReservationID types.ID
			// Consume is the consume argument value.
			Consume bool
		}
	}
	lockReserveResources sync.RWMutex
	lockUpdateResources  sync.RWMutex
}

// ReserveResources calls ReserveResourcesFunc.
func (mock *ProductServiceMock) ReserveResources(ctx context.Context, reservationID types.ID, reservation Reservation) (Reservation, error) {
	if mock.ReserveResourcesFunc == nil {
		panic("ProductServiceMock.ReserveResourcesFunc: method is nil but ProductService.ReserveResources was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID types.ID
		Reservation   Reservation
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
		Reservation:   reservation,
	}
	mock.lockReserveResources.Lock()
	mock.calls.ReserveResources = append(mock.calls.ReserveResources, callInfo)
	mock.lockReserveResources.Unlock()
	return mock.ReserveResourcesFunc(ctx, reservationID, reservation)
}

// ReserveResourcesCalls gets all the calls that were made to ReserveResources.
// Check the length with:
//     len(mockedProductService.ReserveResourcesCalls())
func (mock *ProductServiceMock) ReserveResourcesCalls() []struct {
	Ctx           context.Context
	ReservationID types.ID
	Reservation   Reservation
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID types.ID
		Reservation   Reservation
	}
	mock.lockReserveResources.RLock()
	calls = mock.calls.ReserveResources
	mock.lockReserveResources.RUnlock()
	return calls
}

// UpdateResources calls UpdateResourcesFunc.
func (mock *ProductServiceMock) UpdateResources(ctx context.Context, reservationID types.ID, consume bool) error {
	if mock.UpdateResourcesFunc == nil {
		panic("ProductServiceMock.UpdateResourcesFunc: method is nil but ProductService.UpdateResources was just called")
	}
	callInfo := struct {
		Ctx           context.Context
		ReservationID types.ID
		Consume       bool
	}{
		Ctx:           ctx,
		ReservationID: reservationID,
		Consume:       consume,
	}
	mock.lockUpdateResources.Lock()
	mock.calls.UpdateResources = append(mock.calls.UpdateResources, callInfo)
	mock.lockUpdateResources.Unlock()
	return mock.UpdateResourcesFunc(ctx, reservationID, consume)
}

// UpdateResourcesCalls gets all the calls that were made to UpdateResources.
// Check the length with:
//     len(mockedProductService.UpdateResourcesCalls())
func (mock *ProductServiceMock) UpdateResourcesCalls() []struct {
	Ctx           context.Context
	ReservationID types.ID
	Consume       bool
} {
	var calls []struct {
		Ctx           context.Context
		ReservationID types.ID
		Consume       bool
	}
	mock.lockUpdateResources.RLock()
	calls = mock.calls.UpdateResources
	mock.lockUpdateResources.RUnlock()
	return calls
}
